# 几种现代编程语言的设计分析

## 献诗

> Language design is cast in stone, 
>
> but this stone is reasonably soft, 
>
> and with some effort we can reshape it later.

## 现代编程语言

### 什么是现代编程语言

事实上，对于现代编程语言并没有一个统一的定义。不同的研究者通过不同的方面来定义它，例如找出软件工程和现代编程语言发展的联系`\cite{ModernProgrammingLanguagesSoftwareEnginerring}`，或是围绕着“抽象”来阐述`\cite{ModernProgrammingLanguagesAbstraction}`。上面的这些说法在各自适用范围内都是正确的，而这里将其适用的范围再度扩大，通过研究多种定义的交集，得出更加普适的现代编程语言定义。一个显而易见的事实是，随着编程语言实践的不断加深，现代编程语言的定义也在不断发生变化，因为编程语言是实践和理论紧密结合的理论。尽管其定义不断发生变化，但是有些核心内容却是始终不变的。这里给出现代编程语言的几个特性。

1. 实质大于形式。它应当提供描述性的语法结构，而不是手把手告诉机器应当做什么。实质是对机器功能的抽象。
2. 语义一致性。对于相似的语法结构，应当有相似的语法特性。
3. 语法自举。对于非核心的语法特性，在遵循语义一致性的基础上，应当由核心的语法特性组合而成。
4. 范式融合。提供多种编程范式，而不强迫用户使用特定的编程范式。
5. 语法检查。对于潜在的错误，应当在编译期就予以阻止，而不是在运行时出错再进行报告。

### 现代编程语言的更替

编程语言具有相当程度的时效性。对于时间跨度较大的不同时代的不同编程语言，虽然它们都符合上述的现代编程语言的特性，但是其中一方相较于另一方仍然是较为“过时”。这是由于上述原则在时间维度上是冲突的。事实上，实质大于形式要求编程语言抽象出符合具体应用场景的语法特性，而应用场景的需求会随着时间逐渐变化，因为应用场景经过技术迭代会进行技术升级。此时若想在原有的编程语言中加入新的语法特性，这很容易就破坏了语法自举和语义一致性的原则。因此，此时较好的解决方案是设计一门新的编程语言，从语言设计的层面上考虑满足新的需求。

但是，还有一些因素阻碍了编程语言淘汰的进度。编程语言从原型到大规模应用需要较长的时间，在这段时间里，编程语言会逐步完善自己的编程语言生态。编程语言生态就像一张密密麻麻的网，一旦编程语言开始大规模应用，想要将编程语言完全淘汰几乎是不可能的。对于发展中的计算机应用系统，最理想的状态是新的编程语言可以兼容旧的编程语言，从而使得新的编程语言可以继承旧的编程语言的生态，一个典型的例子是C和C++。但是，由于某些不可抗力的存在，很多时候新的编程语言无法兼容旧的编程语言，此时可以通过虚拟机实现编程语言生态的兼容，但是仅限于新的编程语言和旧的编程语言都是基于同一种虚拟机的语言，一个典型的例子是Java和Kotlin。此外，还有一种较为普适的方法是，新编程语言实现旧编程语言的数据接口，大部分语言和C/C++的交互都是这样完成的，但这样做会有较大的功能限制。最后，是一种不依赖于编程语言具体实现的方法，通过引入一个第三方协议来实现低耦合兼容，典型的例子是各个语言的RPC框架。各个编程语言都兼容了一些过去的编程语言，这也是必然的。

淘汰旧的编程语言仍是趋势，不过会以较慢的方式进行。通过对旧的编程语言兼容的方式虽然可以复用过去的过去的编程语言生态，但是由旧编程语言引起的维护性难题仍无法解决。因此，兼容旧的编程语言是一种妥协的做法，先通过旧的编程语言生态发展新的编程语言本身，再以新的编程语言重构旧的编程语言生态，最终实现编程语言的大规模淘汰。

## 编程语言分析简介

### 待分析编程语言的选择

对于编程语言的选择，首要关注的是当下最流行的趋势，因此选择的编程语言要能覆盖最常用的几种。其次，编程语言有许多划分标准，对于每一种划分标准，所选择的编程语言都应当覆盖大部分的选项。然后，应当着重突出近年来具有优秀设计的新生的现代编程语言，这些编程语言吸取了传统编程语言的优点，并修改了其中固有的缺点。从中可以看出这些年来应用导向的编程语言的发展趋势。

根据IEEE spectrum`\cite{IEEETopProgrammingLanguages}`的数据，2021年最流行的前五个最流行的编程语言正是Python、Java、C、C++和JavaScript。但是对于C，它是一种偏向于计算机底层的语言，并不符合现代编程语言的原则。事实上，严格来说，C语言的语法设计不符合现代编程语言原则的任何一条。因此，将C语言排除，剩余的语言加入研究的范畴。而对于剩余的四种编程语言，以当今的眼光看待，现代编程语言的原则并不是完全符合。但是在这些语言刚刚诞生的时代，这些语言都是作为现代编程语言的代表而出现的。因此将这四种传统的编程语言与新兴的现代编程语言进行对比。

根据上述的编程现代编程语言标准选择出数种编程语言，并按照流行顺序进行排列`\cite{IEEETopProgrammingLanguages}`，得到的是Go、Swift、Dart、Rust和Kotlin（其中Swift和Dart流行程度相当）。巧合的是，这些语言的也是按照这个顺序先后发布。另外，这些语言的类型系统都是相似的，并且都支持AOT的编译方式，尽管不都是采用垃圾回收的内存管理方式，但是也都脱离了手动管理内存的方式。这些都是在现在的应用环境下，现代编程语言的普遍特征。

### 待分析编程语言概要

| Language   | Programming Paradigm | Type System         | Compilation Mode | Memory Model | Release Date | Application Scenarios        |
| ---------- | -------------------- | ------------------- | ---------------- | ------------ | ------------ | ---------------------------- |
| Python     | Multi-paradigm       | Dynamicly, Strongly | JIT              | GC           | 1991         | Web, Enterprise, Embedded    |
| Java       | Multi-paradigm       | Staticly, Strongly  | AOT              | GC           | 1995         | Web, Mobile, Enterprise      |
| C++        | Multi-paradigm       | Staticly, Weakly    | AOT              | Manual       | 1983         | Mobile, Enterprise, Embedded |
| JavaScript | Multi-paradigm       | Untyped             | JIT              | GC           | 1995         | Web                          |
| Go         | Multi-paradigm       | Staticly, Strongly  | AOT              | GC           | 2009         | Web, Enterprise              |
| Swift      | Multi-paradigm       | Staticly, Strongly  | AOT              | ARC          | 2014         | Mobile, Enterprise           |
| Dart       | Multi-paradigm       | Staticly, Strongly  | AOT&JIT          | GC           | 2011         | Web, Mobile                  |
| Rust       | Multi-paradigm       | Staticly, Strongly  | AOT              | Ownership    | 2015         | Web, Enterprise, Embedded    |
| Kotlin     | Multi-paradigm       | Staticly, Strongly  | AOT&JIT          | GC           | 2016         | Web, Mobile                  |

![](C:/Users/dawn/Desktop/latex/iccs-latex/iccs.assets/timeline.png)

```latex
\figure{一维坐标-编程语言发布时间}
```

### 语言设计评价标准

这里的评价标准是更加应用导向的，用以评价一个编程语言是否“实用”，而不是像“现代编程语言的原则”一样，评价一个编程语言是否“优雅”。事实上，大多数流行的语言并不优雅，这是因为编程语言的发展不仅仅是技术上的突破，而是涉及到政治、商业以及其他外部因素。一个典型的例子是JavaScript的发展历程。时至今日，主流浏览器的JavaScript的语言标准仍然不统一。但是这并不妨碍JavaScript是Web应用中最实用的语言。而评价语言的是否实用，则应当主要考察两个方面。一个方面是其语法设计。对于复杂的业务逻辑，需要编程语言提供很强的表达能力，将无关于业务逻辑的底层实现隔离，以适应快速变化的需求，还需要编程语言提供检查程序正确性和可靠性的方案。另一个方面是性能，编程语言在运行时总是被期望具有较低的内存开销和时间开销，其主要依靠编译时（本地语言）和运行时（虚拟机语言）的优化。

| 评价项目 | 具体含义                                                     | 相关内容                      |
| -------- | ------------------------------------------------------------ | ----------------------------- |
| 表达能力 | 对于抽象且复杂的业务逻辑，编程语言能提供简洁的描述方式。     | 1.编程范式                    |
| 可维护性 | 按照标准编码规范完成业务逻辑后，后续还便于增加新功能或修复漏洞。 | 1.编程范式 2.类型系统         |
| 可靠性   | 按照标准编码规范完成业务逻辑后，在极端条件下的不崩溃。       | 1.类型系统 2.编程范式         |
| 性能     | 将由该编程语言编写的系统部署在在目标机器上运行时，占用较少的硬件资源。 | 1.运行时间开销 2.运行内存开销 |

但实际上，编程语言设计无法准确的进行定量分析。原因有两个方面。第一个是，某些评价的标准不是定量的分析。对于表达能力和可靠性，两者都是对抽象概念的描述，反映在实践中有不可数种类的情况，无法全部考虑到。虽然可以设计定量的分析，但是必须通过限制某些特定的应用场景才能完成。第二个是，评价的标准不够充分。为了论文结构上的完整，放弃了一些难以测量的评价标准，如实时系统中的响应时间等。对于带有垃圾回收机制的编程语言，垃圾回收带来的性能损耗不可忽略不计。尤其是基于JVM的编程语言，在进行垃圾回收时会有“Stop the World”的问题，这些都会影响编程语言的性能。但是这里为了简便起见不予考虑。

## 编程范式

编程范式来源于人对现实世界认知方式，而编程语言是形式化描述这种认知方式的工具。人们在开发软件时，会将现实世界在计算机中进行模拟，不同的编程范式在于对现实世界建模方式的不同。对世界的建模往往需要解决两个问题。第一是找出世界的基本单位是什么，称之为一等公民。这些一等公民可以存储在变量中，可以作为函数参数和函数返回值被传递，简而言之，就是程序中要被操作的“数据”。第二是找出这些基本单位之间的关系，称之为计算。计算在程序中就可以看作对数据的“操作”。例如面向对象将对象看作一等公民，对象之间的计算称之为方法。再例如函数式将函数看作一等公民，而计算的就是lambda演算，是对函数本身的计算。有趣的是，函数式中函数既是基本单位，又是计算的形式。

编程范式是编程语言最底层的设计。从理论上来说，编程语言需要帮助人们完成对现实世界的建模，因此需要考虑应当提供哪些建模的基础设施，即是编程语言的编程范式。从实践上来说，设计编程语言应当首先考虑一等公民，作为编程语言的基本单位。不同的编程范式之间存在一定的冲突，来源于一等公民的冲突。尤其是对确定范式的编程语言增加新的范式，是非常困难的。一个典型的例子是Java。Java8增加的函数式特性，并不能从根本上改变Java的编程范式，顶多算是语法糖。由于缺少最初的编程范式设计，Java难以完全兼容函数式特性，因此Java中的函数式是残缺的，不优雅的。因此，对于编程语言，尤其是对于多范式的现代编程语言，首先应当确定编程范式，进而确定一等公民。


### 编程语言、范式和概念


![](C:/Users/dawn/Desktop/latex/iccs-latex/iccs.assets/Languages-paradigms-and-concepts.png)

```latex
\figure{Languages, paradigms, and concepts}\cite{van2009programming}
```

 图`ref{fig:concept}`展示了语言，范式和概念之间的关系。每个范式包含一组核心的概念，同时，每个语言也实现了多种范式`\cite{van2009programming}`。

### 函数式与面向对象

函数式和面向对象是现代编程语言中通常具备的编程范式。而各个编程语言对它们的支持程度却并不相同，从表中可以看出各个语言对函数式和面向对象概念的支持程度。

对于组成编程范式的概念，这里选择更加偏向于实践的组织方式。它将更偏向于选择具体编程语言中定义的概念，而不是编程范式理论中定义的概念。例如，对于函数式概念中的嵌套函数和匿名函数，它们在很多编程语言中被实现为lambda表达式。再比如，对于面向对象概念中的组合，目前流行的大多数编程语言都支持它。事实上，对于编程语言设计本身来说，组合仅仅是安排数据的一种方式，它并不属于任何一种范式。甚至像较为古老的语言——C语言，都提供了结构组合和函数组合。因此，并不将其纳入分析。

为了更加准确地区分各个语言编程范式的强弱，这里引入了一些并不常用的概念。这些概念都是属于特定的编程范式，但是通常在讨论多范式编程语言的时候，并不把这种概念当作核心概念，因为这些概念在范式融合的过程中较难实现。例如“statements as expressions”，这一概念在函数式语言中较为常见，它实现了表达式和语句语义上的统一，但大多数面向对象和函数式范式融合的编程语言中都没有实现这一概念。随着编程语言的不断发展，Kotlin和Rust实现了包含此概念的函数式与面向对象范式的融合，因此可以将Kotlin和Rust视为具有更高层次的函数式范式。另一个例子是“everything is object”。根据面向对象的定义，它本应当是面向对象中最核心的概念。但事实上，早期的编程语言往往带有大量的指令式特征，并不是像编程语言中的所有元素都看作对象。例如Java中仍然存在“primitive data types”，它们不是对象，因此我们不能像使用对象一样调用这些类型的方法。或许“primitive data types”有许多性能上的正面因素，但是从语义一致性的角度来讲，“primitive data types”是负面效果的。因此具有“everything is object”概念的语言被认为具有更好的面向对象特征。

而对于面向对象的核心概念，流行语言的支持程度并没有太多的差距。由于其发展历史较为久远，并且近些年来理论上和实践上并没有大的创新，因此大多数的编程语言已经相对完整地实现了面向对象的核心概念。另外，越来越多的编程语言通过支持组合和委托来实现面向对象特性，而单纯的继承已经被证明是糟糕的实践。因此，Go和Rust中抛弃了类和继承的概念，通过trait来实现传统的面向对象。相较于基于class的面向对象，基于trait的面向对象具有更松散的耦合和更灵活的实现。不过，大多数语言都同时支持trait和class，以实现不同粒度的控制。

编程语言的范式与其应用场景有非常密切的关系。尤其是对于单一应用领域的编程语言。一个典型的例子是Dart。它的主要应用场景是Web，通常作为图形用户界面框架Flutter的支持语言。显然易见的是，我们使用的大多数图形用界面框架都有复杂的继承结构。这是因为，对于图形用户界面，大多数应用场景都满足里氏代换原则，即子类型能够完全替换掉夫类型。这是使用继承的充分条件。因此，Dart仅仅提供了基于继承的面向对象概念。另一个例子是Java。Java早年间用于Enterprise开发，为了提高代码的复用性，提供了面向对象范式。后来用于Web服务器，对业务逻辑的抽象有着很高的要求，因此额外增加了函数式的概念。

随着编程语言实践的不断加深，编程语言对函数式概念的支持程度越来越高。有了对于上世纪八九十年代发布的编程语言，编程语言刚诞生时，对函数式的支持并不好。尤其是Java和C++，从最初的语法来看，它们在设计时没有考虑到要实现函数式编程。而对于JavaScript和Python来说则好一些，它们天生支持函数式，但仍缺少了一些高级的函数式概念。对于2010年前后发布的编程语言，则都支持了函数式的基本概念。特别是Rust和Kotlin，还额外支持了“Statements as expressions”的概念，这是现代编程语言范式融合发展上的里程碑。

综上所述，该图大致描述了不同编程语言对函数式编程和面向对象编程概念的支持程度。对于特定的编程语言，在图中越靠近FP/OOP，它对FP/OOP的支持程度就越好。

![](C:/Users/dawn/Desktop/latex/iccs-latex/iccs.assets/paradigm.png)


```latex
\figure{二维坐标-编程语言编程范式}
```


| Concept                 | Meaning                                                      |
| ----------------------- | ------------------------------------------------------------ |
| Higher-order functions  | Take functions as variables, which can pass as parameters or return values. |
| Lambda expression       | A short block of code which takes in parameters and returns a value. |
| Partial application     | Given a function with certain parameters, producing another function (with fewer parameters). |
| Closures                | A record stores a function together with an environment`\cite{sussman1998scheme}`. |
| Type inference          | The automatic detection of the type of an expression at compile time. |
| Pattern matching        | Dispatch branch by matching the pattern of a given sequence of tokens. |
| Statement as expression | Take all statements as expressions, which creates a definite value. |

`\table{函数式编程概念表}`

| Language   | Higher-order functions | Lambda expression | Partial application | Closures | Type inference | Pattern matching | Statements as expressions |
| ---------- | ---------------------- | ----------------- | ------------------- | -------- | -------------- | ---------------- | ------------------------- |
| Python     | √                      | √                 | Python2.5           | √        | √              | Python3.10       | ×                         |
| Java       | Java8                  | Java8             | Java8               | Java8    | Java10         | ×                | ×                         |
| C++        | C++11                  | C++11             | C++11               | C++11    | C++11          | C++17            | ×                         |
| JavaScript | √                      | √                 | ECMAScript5         | √        | √              | ECMAScript6      | ×                         |
| Go         | √                      | √                 | √                   | √        | √              | ×                | ×                         |
| Swift      | √                      | √                 | √                   | √        | √              | √                | ×                         |
| Dart       | √                      | √                 | √                   | √        | √              | ×                | ×                         |
| Rust       | √                      | √                 | √                   | √        | √              | √                | √                         |
| Kotlin     | √                      | √                 | √                   | √        | √              | √                | √                         |

`\table{函数式编程概念表}`

| Concept              | Meaning                                                      |
| -------------------- | ------------------------------------------------------------ |
| Encapsulation        | Hide the properties and implementation details of the object, and only expose the interface to the outside. |
| Inheritance          | Create classes that are built upon existing classes`\cite{johnson1988designing}`. A way of code reuse. |
| Composition          | Combine entities into more complex ones. A way of code reuse. |
| Delegation           | One entity passing something to another entity`\cite{wilkinson2009grid}`. A way of code reuse. |
| Traits               | A set of method conventions. Broadly including trait, interface, protocol and mixin. |
| Polymorphism         | Use of a single symbol to represent multiple different types`\cite{cardelli1985understanding}`. |
| Everything is object | All the basic elements of a programming language are represented in the form of objects. |

`\table{面向对象编程概念表}`

| Language   | Inheritance | Delegation | Traits | Polymorphism | Everything is object |
| ---------- | ----------- | ---------- | ------ | ------------ | -------------------- |
| Python     | √           | √          | ×      | √            | √                    |
| Java       | √           | ×          | √      | √            | ×                    |
| C++        | √           | ×          | √      | √            | ×                    |
| JavaScript | √           | √          | ×      | √            | √                    |
| Go         | ×           | ×          | √      | √            | ×                    |
| Swift      | √           | ×          | √      | √            | √                    |
| Dart       | √           | ×          | ×      | √            | √                    |
| Rust       | ×           | √          | √      | √            | √                    |
| Kotlin     | √           | √          | √      | √            | √                    |

`\table{面向对象编程概念表}`

### 编程范式与编程语言分析

对于具有相同相同编程范式的编程语言，在表达能力、可维护性、可靠性和性能上具有相似的表现。前文中提到过，编程范式是对现实世界建模的方式。不同的建模范式往往会有一些不同的特性。对于特定的建模方式，它的内容和形式决定了它对应的编程范式中的一些固有特性。因此我们可以通过编程范式来分析编程语言的特性。

函数式编程最主要的特征就是其高度的抽象性。这主要是因为函数式编程起源于lambda calculus，因此其具备了抽象代数的部分特征。在函数式语言的实践中，主要思路是高阶函数的组合与嵌套，所以其设计核心就是理清高阶函数的嵌套与组合规则。因此，可以将其基本设计方法描述为：通过函数传递模型的标准化与高阶函数的可组合性，通过一系列的规则设计，完成数据从源头到结果的映射的描述。这里的映射是通过多个高阶函数的形式化组合完成的。描述就像数学公式，将输入的数据经过层层迭代，映射成结果。对于广义上数据的迭代过程，其中不仅仅包括数据本身的迭代，还包含规则的迭代。这是由于函数式语言中，数据与规则在语义上统一于函数。

由此可以得出函数编程的特点。

1. 高表达能力。函数式编程是数据化的表达，具有高度的抽象性，因此在其表达范围内可以以极少的代码完成业务逻辑。
2. 在一定范围内的高可维护性。第一，函数式编程是声明式表达，易于理解。第二，高阶函数的粒度较小，可组合能力较强。但是其高可维护性是有一定条件的。第一，业务逻辑是复杂的，不是在每个方面都能做到逻辑上的自洽，因此找到一套完整的规则映射是困难的。第二，既是在某个狭窄的领域找到了映射的规则，但一旦需要拓展到新的领域，原来的规则就会失效。
3. 高可靠性。由于函数式语言基于lambda calculus，对函数式代码进行形式化验证是较为容易的。由此可以保证正确性与可靠性。
4. 图灵机上的较差性能。函数式语言中，语法规则与图灵机之间有较多中间层，还有其语法规则和惰性求值等，使得优化较为困难。

面向对象最主要的特征就是强调复用。早在1960s，由于不断增加的软硬件复杂性，软件的维护变得愈发困难。面向对象通过强调可复用性来解决这个问题。在面向对象语言的实践中，人们将现实问题映射成实体及其关系，而不是关心处理问题的过程。面向对象语言诞生后，人们迫切需要从问题映射成实体及关系的建模方式，此时UML应运而生。它是一整套图标组成的标准化建模语言，极大的推动了面向对象方法学的发展。这种方法强调建模与设计的重要性。

同样的，可以得到面向对象编程的特点。

1. 一定的表达能力。封装虽然提高了代码抽象程度，但实质上转移并分割了业务逻辑。此外，面向对象复杂的层级结构也降低了其表达能力。设计模式的出现就是为了弥补面向对象表达能力上的缺陷。
2. 高维护性。第一，对象本身的可复用性强，适用的领域较多。第二，多态提高了响应变化的能力。第三，封装有利于维护者的理解成本。
3. 一定的可靠性。面向对象建模依赖于实践经验，缺乏严格的理论证明。面向对象建模通常的最佳实践局限在了归纳法的范畴。
4. 较好的性能。面向对象可以做到接近图灵机的原生性能。大多数性能开销的地方，例如动态绑定，函数调用开销，都可以通过编译手段进行优化。

## 类型系统



![type-definition](C:/Users/dawn/Desktop/latex/iccs-latex/iccs.assets/type-definition.png)

```latex
\figure{编程语言类型系统定义}
```


为了定义上的精确，这里采取的是L Cardelli的类型系统定义`\cite{cardelli1996type}`。这种定义方式认为，类型系统的根本目的是要防止程序在运行过程中出现的错误，因此通过定义与错误相关的概念来定义类型系统。首先定义何为错误来定义行为良好。再根据行为检查的时机，划分为动态检查和静态检查。在静态检查的基础上，通过是否能检查出forbidden error来划分强类型检查和弱类型检查。而对于编程语言中的实际类型，则根据是否存在静态类型来限制运行时的变量范围，从而划分出有类型（静态）语言和无（静态）类型语言。再根据是否显式地指明变量的类型，划分出显式类型语言和隐式类型语言。

一个极具迷惑性的问题是，不同语境下的对编程语言类型系统的定义是不同的。并且有一部分人在讨论编程语言的类型时，不指明类型系统的定义，这就容易导致实践中对类型系统的无意义的争论。一部分人认为，JavaScript是动态、弱类型语言，而非这里所判断的无类型语言。这种判断方法也是正确。事实上，这种判断标准的定义是基于值和变量，而非这里的错误检查。另一个值得讨论的事情是Python。Python在3.5版本引入了type hints。但实际上type hints并没有实际上对Python进行错误检查，仅仅是一种类型注释，以帮助静态分析语法分析程序提供更好的支持。错误检查的真正时机仍然是在运行时。

| Language   | Typed/Untyped | Explicitly/Implicitly typed | Dynamically/Staticly checked | Strongly/Weakly checked | Well behaved |
| ---------- | ------------- | --------------------------- | ---------------------------- | ----------------------- | ------------ |
| Python     | Typed         | Implicitly                  | Dynamically                  | Strongly                | Yes          |
| Java       | Typed         | Explicitly                  | Staticly                     | Strongly                | Yes          |
| C++        | Typed         | Explicitly                  | Staticly                     | Weakly                  | No           |
| JavaScript | Untyped       | -                           | Dynamically                  | -                       | Yes          |
| Go         | Typed         | Explicitly                  | Staticly                     | Strongly                | Yes          |
| Swift      | Typed         | Explicitly                  | Staticly                     | Strongly                | Yes          |
| Dart       | Typed         | Explicitly                  | Staticly                     | Strongly                | Yes          |
| Rust       | Typed         | Explicitly                  | Staticly                     | Strongly                | Yes          |
| Kotlin     | Typed         | Explicitly                  | Staticly                     | Strongly                | Yes          |

类型系统对于编程语言的作用是显而易见的。

+ 降低了表达能力。相较于无类型语言，有类型语言的表达能力有一定程度的降低。但是可以通过提高类型系统的复杂性来提高表达能力，例如范型、联合类型等。
+ 提高了可维护性。类型签名包含了约束信息，可以通过类型签名来间接判断变量或函数的功能。
+ 提高了可靠性。第一，类型系统提供了检查错误的手段。第二，可以通过类型系统形式化证明程序的正确性。
+ 提高了性能。第一，无类型语言在运行时，类型的检查、转换都会产生额外的性能开销。第二，无类型不利于编译优化。一些常见的JIT优化例如循环展开难以在无类型语言中进行。第三，无类型内存内存分配更为低效。

## 编程语言性能

在工业界中往往会有对编程语言效率的争论，因为程序的执行效率往往代表了程序的性能。对于同样的硬件条件，执行效率较高的编程语言往往意味着更大的负载、更低的延迟，反映到现实世界中就是更好的用户体验和更低的成本。对于编程语言性能的争论自计算机诞生以来就没有停止过，但是如今谈起来性能时，大多数人往往会认同C++的性能高于Java，认同C++性能高所以应当拿来写高性能计算。这个观点并不能说是错的，但是大多数人都没有搞清楚，当谈起来编程语言的性能的时候，到底在谈论什么。影响编程语言的性能的因素有很多，并不能单纯地认为某一种语言的性能高于另一种语言，尤其是有特定的应用场景时，编程语言的性能往往与场景的设定密切相关。这引出了基准测试的概念。

基准测试提供了一种系统化测试同一种类下不同个体的性能差异的方法，为科学地判断个体优劣提供了基础`\cite{hockney1996science}`。一般在计算机科学中，基准测试指的是通过运行某个计算机程序或某些操作的特定行为，用以评估对象的性能，通常是通过一系列控制变量的对比实验`\cite{fleming1986not}。`通常涉及几个迭代轮次，以便得出可复现的、精确的结论。另外，它侧重于某一程序，应当排除无关程序对基准测试的影响，这要求基准测试应当清楚地知道底层的工作原理，避免系统的状态不确定性带来的误差。基准测试在计算机中最早应用于计算机硬件，一个常见的例子是GPU的浮点性能。但近年来也可用于计算机软件，例如对编译器和数据库的基准测试。

### 影响编程语言性能的因素

单从影响的覆盖范围来看，编译原理对编程语言的效率影响是最大的。在工业应用中，多数场景下的性能瓶颈是编译相关的，这里编译指的是广义上的编译，不仅包括编译时，还包括运行时。编译对编程语言效率的影响又是多个方面的。第一，对于相同的编程语言，采用不同的编译器往往会有不同的目标代码，从而有不同的运行效率，这常常是因为编译时的优化效果不同，比如对于C++，Clang-LLVM的编译方式相对于采用GCC的编译方式得到的目标代码在运行时就有明显的性能差异。第二，对于相同的编程语言，不仅可以采取AOT（Ahead Of Time）的方式编译，还可以采用JIT（Just In Time）的方式编译，比如对于Kotlin，不仅可以编译成字节码运行在JVM，还可以编程成JavaScript代码运行在浏览器上，甚至可以采用Kotlin Native，编译成本地代码。这样以来，不同的编译方式对效率的影响就更大了。

![](C:/Users/dawn/Desktop/latex/iccs-latex/iccs.assets/compilation.png)

```latex
\figure{图-编程语言编译模式}
```

内存管理虽然在日常使用时不显山露水，但是实际上内存管理对编程语言性能的影响是巨大的。第一，有关于堆上内存分配。对于带有虚拟机的语言，相较于非虚拟机语言，内存内存是有很大的优势的，这是因为虚拟机语言往往会提供内存池，对内存分配进行托管，而非虚拟机语言则没有这样的优势。当然，对于频繁使用堆上内存的场景下，非虚拟机语言往往会使用自定义的或第三方提供的内存池框架，工业中的性能差距并没有这么明显。同样，对于虚拟机语言来说，托管的内存池也并非全是好事，当发生内存抖动时，虚拟机会频繁地进行GC，这也影响了性能。第二，有关于内存的局部性原理。若是顺序访问内存，CPU会将相邻的数据都放入Cache中，大大提高了Cache的命中率，从而提高了性能。同时配合编译器的循环展开优化，则会达到更高的效率。若是对内存进行随机访问，则性能就要大打折扣。

![](C:/Users/dawn/Desktop/latex/iccs-latex/iccs.assets/memory.png)

```latex
\figure{树-编程语言内存模型}	
```

### 基准测试设置

计算机语言的基准测试游戏动态度量指标，是出自于目前比较流行的跨语言基准测试套件之一——计算机语言基准测试游戏的思路`\cite{gouy2017computer}`。计算机语言基准测试游戏目前由10个基准程序组成。每一个都提供了一个完全不同的问题，针对这个问题，使用不同的语言规范、语言特性和方法，试图使用最通用的方式来解决它们。

本此测试中，使用Python脚本统一进行粗粒度的批量测试，使用内置的进程工具调用Linux系统命令，不依赖第三方库。它有较高的测试效率，适合大量数据的测试。对每一个测试程序都执行执行6次，取平均值以避免误差。每个基准测试都执行了较大规模和较小规模的输入。所用测试平台的参数，见表`\ref{tab:platform}`。编程语言的编译参数，见表。

| Language   | Version         | Dependency |
| ---------- | --------------- | ---------- |
| Python     | CPython3.8      |            |
| Java       | OpenJDK17       |            |
| C++        | Clang14/GCC11.2 |            |
| JavaScript | Node16          |            |
| Go         | Go1.17          |            |
| Swift      | Swift5.5        |            |
| Dart       | Dart2.16        |            |
| Rust       | Rust1.54        | MinGW7.3   |
| Kotlin     | Kotlin1.6       | OpenJDK8   |

对于每一种语言，有4个测试指标，分别是：


+ 编译器。标注在编程语言后，若无标注则使用官方编译器。
+ gzip。gzip是工业界常用的传输压缩协议。用以表示源代码压缩后的大小。
	对于同样的算法，某个编程语言使用的代码数量越少，则大致上可以认为该语言的语法表达能力越高。
+ 时间。运行该算法所需的时间。用多次运行的最小值表示。包括启动时间。
+ 空间。运行该算法峰值空间消耗。用多次运行的最大值表示。

### binary-trees

使用的是Hans-J. Boehm的GC bench算法`\cite{demers1989combining}`。
通过反复大量分配、回收空间，测量的内存分配能力和垃圾回收能力。步骤如下：

+ 动态构建大量低深度的完全二叉树，遍历之，最后回收这些空间。
+ 重复第一步，并逐渐增加二叉树的深度，减少二叉树的数量，使每次遍历分配的节点数大致相同，直至二叉树的个数足够少。
+ 构建一颗和上述步骤节点总数大致相同的二叉树，并统计节点的数量。


```latex
\begin{tabular}{lrrrr}
\toprule
{} &   n &  size(B) &   cpu(s) &  mem(KB) \\
lang      &     &          &          &          \\
\midrule
cpp-clang &  21 &      654 &   16.438 &   263580 \\
cpp-gcc   &  21 &      654 &   22.181 &   263620 \\
dart-aot  &  21 &     1212 &   45.461 &   799012 \\
dart-jit  &  21 &     1212 &   61.531 &  1626352 \\
go        &  21 &      482 &   50.955 &   220548 \\
java      &  21 &      552 &    5.607 &  2015512 \\
js-node   &  21 &      711 &   36.391 &  1130788 \\
kt-jvm    &  21 &      494 &    8.923 &  1783144 \\
python3   &  21 &      589 &  169.912 &   442180 \\
rust      &  21 &      751 &    7.796 &   132508 \\
swift     &  21 &      714 &   63.608 &   733144 \\
\bottomrule
\end{tabular}
```

```latex
\begin{tabular}{lrrrr}
\toprule
{} &   n &  size(B) &  cpu(s) &  mem(KB) \\
lang      &     &          &         &          \\
\midrule
cpp-clang &  14 &      654 &   0.087 &     1200 \\
cpp-gcc   &  14 &      654 &   0.104 &     3928 \\
dart-aot  &  14 &     1212 &   0.120 &     1680 \\
dart-jit  &  14 &     1212 &   0.644 &   170008 \\
go        &  14 &      482 &   0.214 &     7232 \\
java      &  14 &      552 &   0.155 &    47968 \\
js-node   &  14 &      711 &   0.717 &    90512 \\
kt-jvm    &  14 &      494 &   0.249 &    36040 \\
python3   &  14 &      589 &   0.911 &    14420 \\
rust      &  14 &      751 &   0.042 &     1176 \\
swift     &  14 &      714 &   0.299 &    17616 \\
\bottomrule
\end{tabular}
```

### n-nody

使用的是K. P. Rauch和D. P. Hamilton的Symplectic Integration算法`\cite{rauch2012hnbody}`
模拟太阳系多个行星的演进过程，并通过检查每个演进状态的能量来确认算法的正确性。
性能瓶颈主要集中在浮点运算。步骤如下：

+ 初始化太阳系动力系统。
+ 按照一定的间隔对动力系统进行演进，并计算当前系统的能量。
+ 重复上一步多次，直到演进的时间足够长。

```latex
\begin{tabular}{lrrrr}
\toprule
{} &         n &  size(B) &   cpu(s) &  mem(KB) \\
lang      &           &          &          &          \\
\midrule
cpp-clang &  50000000 &     1173 &    5.926 &     1236 \\
cpp-gcc   &  50000000 &     1173 &    7.555 &     1228 \\
dart-aot  &  50000000 &     1266 &   10.220 &     9308 \\
dart-jit  &  50000000 &     1266 &   13.193 &   143436 \\
go        &  50000000 &     1310 &    6.581 &     1128 \\
java      &  50000000 &     1430 &    7.816 &    37260 \\
js-node   &  50000000 &     1268 &    8.550 &    39956 \\
kt-jvm    &  50000000 &     1124 &    6.914 &    37068 \\
python3   &  50000000 &     1196 &  541.319 &     7780 \\
rust      &  50000000 &     1480 &    5.818 &     1024 \\
swift     &  50000000 &     1192 &    9.585 &     6308 \\
\bottomrule
\end{tabular}
```

```latex
\begin{tabular}{lrrrr}
\toprule
{} &        n &  size(B) &  cpu(s) &  mem(KB) \\
lang      &          &          &         &          \\
\midrule
cpp-clang &  5000000 &     1173 &   0.621 &     1204 \\
cpp-gcc   &  5000000 &     1173 &   0.766 &     1204 \\
dart-aot  &  5000000 &     1266 &   1.033 &     9216 \\
dart-jit  &  5000000 &     1266 &   1.918 &   143256 \\
go        &  5000000 &     1310 &   0.661 &      816 \\
java      &  5000000 &     1430 &   0.880 &    37460 \\
js-node   &  5000000 &     1268 &   0.941 &    39864 \\
kt-jvm    &  5000000 &     1124 &   0.826 &    37064 \\
python3   &  5000000 &     1196 &  52.530 &     7800 \\
rust      &  5000000 &     1480 &   0.579 &     1020 \\
swift     &  5000000 &     1192 &   0.976 &     6308 \\
\bottomrule
\end{tabular}
```

### mandelbrot

在分辨率为N×N位图上，画出mandelbrot set。复数轴上的位置是[-1.5-i,0.5+i]。对于每个像素，进行一定次数的迭代，以确定当前像素的颜色。以pbf格式按照顺序逐byte输出。通过与标准输出对比以检查正确性。该测试的性能瓶颈集中在浮点运算和输出。

```latex
\begin{tabular}{lrrrr}
\toprule
{} &      n &  size(B) &   cpu(s) &  mem(KB) \\
lang      &        &          &          &          \\
\midrule
cpp-clang &  16000 &      822 &   13.900 &    30172 \\
cpp-gcc   &  16000 &      822 &   13.931 &    28696 \\
dart-aot  &  16000 &      454 &  154.089 &    17240 \\
dart-jit  &  16000 &      454 &  151.501 &   148144 \\
go        &  16000 &      823 &   19.598 &    32412 \\
java      &  16000 &      665 &   27.834 &    34264 \\
js-node   &  16000 &      373 &  130.638 &    42020 \\
kt-jvm    &  16000 &      407 &   30.032 &    28432 \\
python3   &  16000 &      688 &  702.599 &    47780 \\
rust      &  16000 &      868 &   11.904 &    38528 \\
swift     &  16000 &      394 &   26.277 &     6200 \\
\bottomrule
\end{tabular}
```

```latex
\begin{tabular}{lrrrr}
\toprule
{} &     n &  size(B) &  cpu(s) &  mem(KB) \\
lang      &       &          &         &          \\
\midrule
cpp-clang &  4000 &      822 &   0.880 &     1552 \\
cpp-gcc   &  4000 &      822 &   0.881 &     1192 \\
dart-aot  &  4000 &      454 &  10.276 &    17380 \\
dart-jit  &  4000 &      454 &  10.096 &   148084 \\
go        &  4000 &      823 &   1.260 &     2420 \\
java      &  4000 &      665 &   1.827 &    34352 \\
js-node   &  4000 &      373 &   8.763 &    42540 \\
kt-jvm    &  4000 &      407 &   2.419 &    28448 \\
python3   &  4000 &      688 &  46.273 &    12172 \\
rust      &  4000 &      868 &   0.757 &     4388 \\
swift     &  4000 &      394 &   1.661 &     6240 \\
\bottomrule
\end{tabular}
```

### 结果分析

首先说明该章节的分类规则。对于同一种语言有不同的编译器或编译方式，则对比不同的编译方式带来的差异（例如C++、Dart）。剩余的语言，按照编程语言类型系统和执行方式进行分类。因为对于多种相同类型系统和编译方式的语言，它们在实践中的应用范围应当是有重合的地方，因此对比分析。

对于同样的C++代码，采用Clang-LLVM的方式进行编译的程序，无论是在binary-trees还是在n-nody，相较于GCC编译的程序，都有着运行速度上的优势。而二者的运行空间是总体上是差不多的。而对于mandelbrot这种输出占据较大开销的测试，二者的各方面性能都是差距不大的。因为二者底层的系统调用的都是类似的。二者的编译器架构是有所不同的，Clang-LLVM采用的是低耦合的前后端分离的架构，而GCC采用的是前后端耦合的架构，这是由于GCC诞生的年代相对古老一些，受限于时代背景。由此可见，对于本地编译型的语言，编译器的编译时优化占据较为重要的地位。

对于同样的Dart代码，采用的是JIT和AOT两种不同的方式编译。对于内存开销和时间开销，无论是binary-trees还是n-nody，看起来AOT的编译方式都有绝对的优势。而对于mandelbrot，JIT和AOT的时间开销是相差无几的，内存开销有着巨大的差异。这是Dart的编译机制引起的。事实上，Dart的编译和运行机制与传统的方式都有所不同。传统的AOT是直接将程序代码编译为目标机上的目标代码，可以直接被操作系统调用、独立运行。但是对于Dart来说，无论是AOT或是JIT，仅仅只有编译时刻的不同，到头来都是要在虚拟机上运行的。这样做的坏处显而易见，会显著增加AOT模式的运行开销，但是这却使得AOT编译拥有了强大的运行时支持。正是因为这种特性，使得Dart虚拟机可以保存当前的运行状态，下次启动虚拟机的时候就可以直接加载上次的状态而不用重新启动。这样做主要是为了开发时的流畅体验，加之增量编译的特性，使之运行结果几乎随着代码的改动而实时变化，延迟极小。这样设计是因为Dart主要作为前端跨平台框架Flutter的开发语言被使用，使得对UI界面的改动可以实时反馈，而其他语言很难做到这一点。

由于Kotlin和Java都是基于JVM，所以它们有着相似的性能数据。但二者基于的JVM版本却有所不同。Kotlin基于的JVM版本是Java8，而Java基于的JVM版本是Java17。从Java9开始，JVM默认的GC是G1。相较于Java8的Parallel，G1是针对服务器GC，在大内存多核心的情况下，有着比Parallel更优秀的响应时间，但同时也消耗了更多的内存。这与表中Kotlin的时间开销略高于Java、内存开销略低于Java的数据是完全吻合的。由表可以看出Java的内存分配与管理速度是这几个编程语言中最优的，耗时极少。但是相对的，Java却有这几种编程语言中最大的内存消耗。可看出Java的内存分配策略是倾向于空间换取时间。对于浮点运算，Java的时间消耗并不算很高。Java由于JIT优化机制的存在，并没有落于本地编译语言太多。Java运行总时间较短的算法程序性能瓶颈主要在于JVM的启动时间和JIT优化的预热时间，对于已经完成预热的算法，Java的执行速度丝毫不落后于本地编译型语言。Java代码的执行过程也比较有意思，并不能用传统的解释执行或编译执行概括。第一步，源代码编译为字节码；第二步，JVM解释执行字节码。同时，JVM会受集代码的运行时信息，若发现某些字节码的执行频率较高，则会选择将此部分字节码进行编译，编译成本地代码，再次执行时直接调用本地代码。而Java所谓的性能优化主要集中在字节码的编译阶段，而源代码到字节码的阶段只进行了简单的优化。

JavaScript和Python都是常用的脚本语言，但他们却有明显的性能差距。JavaScript在Google的V8引擎下，有着出色的性能表现。V8引擎执行js代码的过程和Java虚拟机执行字节码的过程很像，同样是采用了JIT优化的技术，所以相较于没有使用JIT优化的Python，它的性能有着巨大的提升，甚至和Java以及本地编译语言有着相差无几的浮点运算性能。至于内存分配的性能，JavaScript做的要比Dart的JIT好一些，空间和时间开销有着不错的平衡。事实上，大部分的应用场景下脚本语言的运行速度都不是性能瓶颈。但近年来JavaScript有最为“网页中的汇编”的趋势，越来越多的语言开始支持编译成JavaScript，例如Kotlin、Dart等，因此越来越多的业务逻辑需要通过JavaScript来执行，这就使得JavaScript负担了业务相关的繁琐逻辑，对于JavaScript的优化也是大势所趋。

同为现代强类型、编译型语言的Rust、Go和Swift采用的是三种不同的内存管理模型。Go采用的是垃圾回收机制。虽然Go是编译型语言，但却有了额外的运行时以支持垃圾回收。同Java相比，Go采用的垃圾回收策略更为保守，并没有大刀阔斧地采用空间换时间的策略，使得其在内存分配测试中有不错的空间消耗和不太乐观的运行时间。而Rust采用的是所有权机制，不同于纯手动管理的C/C++，也不同于Go的垃圾回收。所有权机制的概念来自于C++的智能指针，但是与之不同的是，Rust采用了编译级别的安全检查来保证大多数可能存在的内存问题都会在编译期检查出来。从底层实现上来说，Rust实际上并没有维护运行时来对空间进行管理，而是通过复杂的算有权算法在编译时确定回收内存的时机。因此，Rust的内存管理是没有开销的。事实上，Rust的编译器后端采用的是LLVM，和上述测试的Clang-LLVM组是同样的后端，从测试数据中也可以看出，Rust在浮点运算上与Cpp-Clang的性能几乎一样。但是由于Rust的所有权机制，在内存分配测试上，Rust更胜一筹。而对于Swift，其内存管理机制与上述都有所不同。Swift通过维护运行时的引用计数来进行内存分配和回收。此外，Swift强制原子地更新引用计数，而不是Rust在编译器对线程安全进行管理，这会导致高昂的CPU开销。由此可见，Swift相较于Rust有着更高的运行时开销，应证了Swift相较于Rust表现不佳的数据。
