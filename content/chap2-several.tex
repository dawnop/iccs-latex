\section{Several modern programming languages and their designs}

There is no uniform definition for MPL\@.
Many researchers define it in different ways, such as finding
connections between software engineering\cite{ModernProgrammingLanguagesSoftwareEnginerring}
and the development of MPLs or elaborating
around abstractions\cite{ModernProgrammingLanguagesAbstraction}.
The above are correct in their respective fields,
and here the definition is abstracted and extended to
adapt to more domains.
By studying the intersection of different definitions,
a more general definition of MPLs derives.
It is an obvious fact, that as the practice of
programming languages continues to deepen, so does
the definition of MPL. This is because PLT is a field
where practice and theory go hand in hand.
Although its definition is constantly changing, some
core elements remain the same.
Here are a few features of MPLs.

\begin{enumerate}
    \item Substance over form. It should provide descriptive grammatical structures, rather than hand-in-hand telling the machine what to do. This item emphasizes the abstraction of machine functions.
    \item Semantic consistency. For similar grammatical structures, there should be similar grammatical functions.
    \item Syntax bootstrapping. For non-core grammatical features, based on following semantic consistency, they should be composed of core grammatical features.
    \item Paradigm convergence. Multiple programming paradigms should be provided without forcing users to use a particular programming paradigm.
\end{enumerate}

\subsection{Selecting modern programming languages to be analyzed}

For the selection of programming language, the first thing is to pay attention to the most popular trend at the moment, so the selected programming language must cover the most commonly used. Secondly, there are many classification standards for programming languages. For each division standard, the selected programming language should cover most of the options. Then, it should focus on highlighting the new programming language with excellent design in recent years. These programming languages have absorbed the advantages of past programming languages and improved their inherent shortcomings. From these selected MPLs, we can see the development trend of application-oriented programming languages over the years.

According to the data of the IEEE spectrum\cite{IEEETopProgrammingLanguages},
the top five most popular programming languages in 2021 are Python, Java, C, C ++, and JavaScript. An exception case is C, which provides low-level access to computer systems. To be precise, the syntax design of the C language does not conform to any of the features of MPL. And for the four remaining popular programming languages mentioned above, they are still helpful even though they are not exactly in line with the features of MPL. In the era when these languages were first created, they emerged as representatives of MPLs. Therefore these four past programming languages are compared with the emerging MPLs.

\begin{figure}[htbp]
    \centerline{\includegraphics[scale=0.6]{figures/timeline}}
    \caption{Timeline of several MPLs}
    \label{fig:timeline}
\end{figure}


Based on the above-mentioned MPL features,
several programming languages were selected and arranged
in order of popularity\cite{IEEETopProgrammingLanguages},
resulting in Go, Swift, Dart, Rust and Kotlin (where Swift and Dart are equally popular). Coincidentally, these languages are also released in this order sequentially. In addition, all of these languages have similar type systems and all support AOT compilation, and although not all use garbage collection memory management, they all move away from manual memory management. These are all common features of MPLs in today's application environment.

\begin{table*}[hbtp]
    \caption{Several modern programming languages}
    \label{tab:selected-languages}
    \begin{center}
        \begin{tabular}{ccccccc}
            \toprule
            Language & Programming Paradigm & Type System & Compilation Mode & Memory Model &
            Release Date & Application Scenarios \\
            \midrule
            Python & Multi-paradigm & Dynamically, Strongly & JIT & GC & 1991 & Web,
            Enterprise, Embedded \\
            Java & Multi-paradigm & Statically, Strongly & AOT & GC & 1995 & Web,
            Mobile, Enterprise \\
            C++ & Multi-paradigm & Statically, Weakly & AOT & Manual & 1983 & Mobile,
            Enterprise, Embedded \\
            JavaScript & Multi-paradigm & Untyped & JIT & GC & 1995 &
            Web \\
            Go & Multi-paradigm & Statically, Strongly & AOT & GC & 2009 & Web,
            Enterprise \\
            Swift & Multi-paradigm & Statically, Strongly & AOT & ARC & 2014 &
            Mobile, Enterprise \\
            Dart & Multi-paradigm & Statically, Strongly & AOT\&JIT & GC & 2011 &
            Web, Mobile \\
            Rust & Multi-paradigm & Statically, Strongly & AOT & Ownership & 2015 &
            Web, Enterprise, Embedded \\
            Kotlin & Multi-paradigm & Statically, Strongly & AOT\&JIT & GC & 2016 &
            Web, Mobile \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{table*}

\subsection{Criteria to evaluate the design of programming languages}

We think there are two main aspects that determine whether a language is useful or not.
One aspect is its syntactic design. For complex business logic, programming languages are required to provide strong expressiveness, i.e., isolate underlying implementations that are not related to the business logic to accommodate rapid changes. Programming languages are also needed to provide solutions for checking the correctness and reliability of programs. Another aspect is performance, where programming languages are always expected to have a low memory overhead and time overhead, relying heavily on compile-time (native languages) and run-time (virtual machine languages) optimizations.

\begin{table*}[hb]
    \caption{Features that a well-designed programming language should have}
    \label{tab:evaluate}
    \begin{center}
        \begin{tabular}{ccc}
            \toprule
            Evaluation Item & Meaning & Related Content \\
            \midrule
            Expressiveness &
            \makecell[l]{
                For abstract and complex business logic, programming \\
                languages can provide a concise way to describe it.
            }
            & Programming Paradigm, Type System \\
            \midrule
            Maintainability &
            \makecell[l]{
                After completing the business logic according to \\
                standard coding specifications, it is also easy to add new \\ features or
                fix bugs subsequently.
            }
            & Programming Paradigm, Type System \\
            \midrule
            Reliability &
            \makecell[l]{
                Non-crash under extreme conditions after completing \\
                business logic according to standard coding specifications.
            }
            & Programming Paradigm, Type System \\
            \midrule
            Performance &
            \makecell[l]{
                Deploying a software system written in this programming \\
                language takes up fewer hardware resources when running \\ on the target
                machine.
            }
            & Time Overhead, Memory Overhead \\
            \bottomrule
        \end{tabular}
    \end{center}
\end{table*}

In practice, however, programming language design cannot be accurately quantified. The reason for this is twofold. The first is that certain criteria for evaluation are not quantitative. For expressiveness and reliability, both are abstract descriptions, and they have uncountable kinds of cases in practice. If one wants to analyze them quantitatively, then one must restrict the analysis to certain specific application scenarios. The second is that the evaluation criteria are not sufficient. Some evaluation criteria that are difficult to measure, such as response time in a real-time system, are dropped here for structural completeness. For programming languages with garbage collectors, the performance loss from garbage collection is not negligible. In particular, JVM-based programming languages have the problem of "Stop the World" when garbage collection is performed, which affects the performance of the programming language. However, this is not considered for the sake of simplicity.
