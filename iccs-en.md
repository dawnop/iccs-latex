# Analysis of the Design of Several Modern Programming Languages

## Introduction

In programming language theory(PLT), programming language design has always been an important topic. Because programming language design integrates various branches of PLT, it is the prerequisite for the final realization of programming language. By analyzing the design of modern programming languages(MPL), we can obtain the trend of programming language development, i.e., the programming language design can be fed back from the application point of view.

By and large, the overall amount of literature on the analysis of programming language design is relatively small. M Coblenz argues that programming language design should be considered in terms of several theories related to programming languages and gives a way of evaluating programming language design. A Stefika gives some issues to consider in programming language design and argues that type systems are crucial for programming languages. However, the above results focus on a qualitative analysis of programming language design and lack some concrete examples. LA Meyerovich analyzes the usage of popular programming languages to give best practices in programming language design through statistics. This analytical approach is somewhat lacking in theoretical and systematic aspects. F Morandat provides a systematic analysis of the R language, including performance, syntactic design, and application scenarios. The article adopts a better research approach and can be used to broaden the analysis perspective based on that article. Currently, there is a lack of a systematic, theoretical and practical, wide-ranging, application-oriented analysis of programming language design.

By analyzing the design of MPL, this paper draws the influence of different programming language factors on the application. e.g., as programming languages evolve, why does the level of paradigm support in MPLs keep changing, what type systems are in MPLs, how MPLs keep programs efficient, and so on.

## Several modern programming languages

There is no uniform definition for MPL. Many researchers define it in different ways, such as finding connections between software engineering and the development of MPLs or elaborating around abstractions. The above are correct in their respective fields, and here the definition is abstracted and extended to adapt to more domains. By studying the intersection of different definitions, a more general definition of MPLs derives. It is an obvious fact, that as the practice of programming languages continues to deepen, so does the definition of MPL. This is because PLT is a field where practice and theory go hand in hand. Although its definition is constantly changing, some core elements remain the same. Here are a few features of MPLs.

1. Substance over form. It should provide descriptive grammatical structures, rather than hand-in-hand telling the machine what to do. This item emphasizes the abstraction of machine functions.
2. Semantic Consistency. For similar grammatical structures, there should be similar grammatical functions.
3. Syntax bootstrapping. For non-core grammatical features, based on following semantic consistency, they should be composed of core grammatical features.
4. Paradigm convergence. Multiple programming paradigms should be provided without forcing users to use a particular programming paradigm.

### Select modern programming languages to be analyzed

For the selection of programming language, the first thing is to pay attention to the most popular trend at the moment, so the selected programming language must cover the most commonly used. Secondly, there are many classification standards for programming languages. For each division standard, the selected programming language should cover most of the options. Then, it should focus on highlighting the new programming language with excellent design in recent years. These programming languages have absorbed the advantages of past programming languages and improved their inherent shortcomings. From these selected MPLs, we can see the development trend of application-oriented programming languages over the years.

According to the data of the *IEEE spectrum*, the top five most popular programming languages in 2021 are Python, Java, C, C ++, and JavaScript. An exception case is C, which provides low-level access to computer systems. To be precise, the syntax design of the C language does not conform to any of the features of MPL. And for the four remaining popular programming languages mentioned above, they are still helpful even though they are not exactly in line with the features of MPL. In the era when these languages were first created, they emerged as representatives of MPLs. Therefore these four past programming languages are compared with the emerging MPLs.

Based on the above-mentioned MPL features, several programming languages were selected and arranged in order of popularity, resulting in Go, Swift, Dart, Rust and Kotlin (where Swift and Dart are equally popular). Coincidentally, these languages are also released in this order sequentially. In addition, all of these languages have similar type systems and all support AOT compilation, and although not all use garbage collection memory management, they all move away from manual memory management. These are all common features of MPLs in today's application environment.

| Language   | Programming Paradigm | Type System           | Compilation Mode | Memory Model | Release Date | Application Scenarios        |
| ---------- | -------------------- | --------------------- | ---------------- | ------------ | ------------ | ---------------------------- |
| Python     | Multi-paradigm       | Dynamically, Strongly | JIT              | GC           | 1991         | Web, Enterprise, Embedded    |
| Java       | Multi-paradigm       | Statically, Strongly  | AOT              | GC           | 1995         | Web, Mobile, Enterprise      |
| C++        | Multi-paradigm       | Statically, Weakly    | AOT              | Manual       | 1983         | Mobile, Enterprise, Embedded |
| JavaScript | Multi-paradigm       | Untyped               | JIT              | GC           | 1995         | Web                          |
| Go         | Multi-paradigm       | Statically, Strongly  | AOT              | GC           | 2009         | Web, Enterprise              |
| Swift      | Multi-paradigm       | Statically, Strongly  | AOT              | ARC          | 2014         | Mobile, Enterprise           |
| Dart       | Multi-paradigm       | Statically, Strongly  | AOT&JIT          | GC           | 2011         | Web, Mobile                  |
| Rust       | Multi-paradigm       | Statically, Strongly  | AOT              | Ownership    | 2015         | Web, Enterprise, Embedded    |
| Kotlin     | Multi-paradigm       | Statically, Strongly  | AOT&JIT          | GC           | 2016         | Web, Mobile                  |

### How to evaluate the design of programming languages

The evaluation criteria here are more application-oriented, to evaluate whether a programming language is "practical" or not. Rather than evaluating whether a programming language is "elegant" as in the features of MPL. In fact, most of the popular languages are not elegant. This is because the development of programming languages is not just a technical matter, but involves political, commercial, and other external factors. A typical example is the evolution of JavaScript. Today, the language standards for JavaScript in mainstream browsers are still not uniform. But this does not prevent JavaScript from being the most popular language for Web applications. But that doesn't stop JavaScript from being the most useful language for Web applications. There are two main aspects that determine whether a language is useful or not. One aspect is its syntactic design. For complex business logic, programming languages are required to provide strong expressiveness, i.e., isolate underlying implementations that are not related to the business logic to accommodate rapid changes. Programming languages are also needed to provide solutions for checking the correctness and reliability of programs. Another aspect is performance, where programming languages are always expected to have a low memory overhead and time overhead, relying heavily on compile-time (native languages) and run-time (virtual machine languages) optimizations.

In practice, however, programming language design cannot be accurately quantified. The reason for this is twofold. The first is that certain criteria for evaluation are not quantitative. For expressiveness and reliability, both are abstract descriptions, and they have uncountable kinds of cases in practice. If one wants to analyze them quantitatively, then one must restrict the analysis to certain specific application scenarios. The second is that the evaluation criteria are not sufficient. Some evaluation criteria that are difficult to measure, such as response time in a real-time system, are dropped here for structural completeness. For programming languages with garbage collectors, the performance loss from garbage collection is not negligible. In particular, JVM-based programming languages have the problem of "Stop the World" when garbage collection is performed, which affects the performance of the programming language. However, this is not considered for the sake of simplicity.

## Analysis of programming paradigms

A programming paradigm is the lowest level of design for a programming language. Theoretically, programming languages need to help people model the real world. Therefore, it is necessary to consider what modeling infrastructure should be provided, i.e., the programming paradigm of the programming language. In practice, programming languages should be designed with first-class citizens in mind, as the basic unit of the programming language. 

There is a certain conflict between different programming paradigms, stemming from the conflict of first-class citizens. In particular, it is very difficult to add a new paradigm to an already defined paradigm programming language. A typical example is Java. The functional features added by Java8 do not fundamentally change the Java programming paradigm, but are at best syntactic sugar. Due to the lack of the original programming paradigm design, Java is hardly fully compatible with functional features. Therefore functional programming in Java are crippled and inelegant. Therefore, for programming languages, especially for MPLs with multiple paradigms, the programming paradigm, and thus the first-class citizens, should be determined first.

Functional Programming (FP) and Object Oriented Programming (OOP) are the two most common, and at the same time the most important paradigms in modern programming languages. Therefore, these two paradigms are chosen for analysis when discussing programming paradigms below.

### Language, paradigm and concept

 The figure shows the relationship between languages, paradigms, and concepts. Each paradigm contains a core set of concepts, and each language also realizes one or more paradigms. FP and OOP are programming paradigms that are commonly available in MPLs. However, the degree of support for them varies from one programming language to another. The table shows the degree of support for the concepts of FP and OOP in each language.

For the concepts in the programming paradigm, a more practice-oriented organization is here. It will favor the choice of concepts defined in specific programming languages over those in programming paradigm theory. For example, for the functional concept of nested and anonymous functions, they are implemented as lambda expressions in many programming languages. Again, for example, for the object-oriented concept of combination, most of the currently popular programming languages support it. For programming language design, the combination is simply a way of arranging data. It does not belong to any paradigm. Even languages like the more ancient one, C, provide structure combinations and function combinations. Therefore, combinations are not included in the analysis.

### Functional programming

The most important feature of FP is its high degree of abstraction. This is mainly because FP has its origins in the lambda calculus, so it has some of the characteristics of abstract algebra. In the practice of FP, the main idea is the combination and nesting of higher-order functions, so the core of its design is to sort out the rules of nesting and combination of higher-order functions. Thus, the basic design approach can be described as follows. Based on the standardization of the function transfer model and the combinability of higher-order functions, the description of the mapping of data from the source to the result is completed through a series of rule designs. Here the mapping is done by a formal combination of several higher-order functions. Descriptions are like mathematical formulas that map input data into results through layers of iterations. For the iterative process of data in a broad sense, which includes not only the iteration of the data itself, but also the iteration of the rules. This is due to the fact that in functional languages, data and rules are semantically unified in functions.

As programming language practice continues to deepen, programming languages are becoming more and more supportive of functional concepts. For programming languages released in the 1980s and 1990s, the support for functional concepts was not good when they were first created. This is especially true for Java and C++. From the original syntax, one did not design them with FP in mind. And for JavaScript and Python, they are a bit better in this regard. Although they inherently support some functional concepts, they are still missing some advanced functional concepts. As for the programming languages released around 2010, they all support the basic functional concept. In particular, Rust and Kotlin additionally support the concept of "statements as expressions", a milestone in the development of MPL paradigm convergence. The concept of "statements as expressions" is more common in functional languages and provides semantic unification of expressions and statements. However, this concept is not supported in most programming languages with paradigm convergence. As programming languages continue to evolve, Kotlin and Rust are supporting this concept with paradigm convergence. Thus Kotlin and Rust can be considered as having a higher level of support for FP concepts.

### Object oriented programming

The most important feature of OOP is its emphasis on reuse. Back in the 1960s, software maintenance became increasingly difficult due to the increasing complexity of hardware and software. OOP solves this problem by emphasizing reusability. In the practice of OOP, one maps real problems into entities and their relationships, rather than being concerned with the process of dealing with the problem. After the birth of object-oriented languages, there was an urgent need to map from problems to entities and relationships in a modeling way, at which point UML was born. It is a set of standardized modeling languages for visualization and has greatly contributed to the development of object-oriented methodologies. Since then the practice of OOP has always emphasized design before implementation.

For the core concepts of OOP, there is not much difference in the level of support of MPLs. Because of its relatively long history and the lack of revolutionary innovations in theory and practice in recent years, most programming languages have implemented the core concepts of OOP relatively completely. In addition, more and more programming languages are realizing object-oriented features by supporting combinations and delegates, while mere inheritance has proven to be bad practice. Therefore, the concept of classes and inheritance is abandoned in Go and Rust, and object orientation is realized through trait. Compared to class-based object-oriented, trait-based object-oriented has a looser coupling and more flexible realization. However, most MPLs support both trait and class for different granularity of control.

In order to more accurately distinguish the degree of OOP concept support for each MPL, some concepts that are not commonly used are introduced here. An example is "everything is object". According to the definition of OOP, it should have been the most basic concept in OOP. In fact, however, early programming languages tended to have a large number of imperative features, i.e., not all elements were treated as objects. For example, there are still primitive data types in Java, which are not objects, so we cannot call methods of these types as if they were objects. Perhaps there are many performance positives of primitive data types, but from a semantic consistency perspective, primitive data types have negative effects. Therefore, languages with the concept of "everything is object" are considered to have a higher level of OOP support.

### Programming Paradigms and Applications

The above discussion leads to this diagram, which roughly depicts the degree of support for FP and OOP concepts in different programming languages. For a given programming language, the closer it is to FP/OOP in the figure, the better it supports FP/OOP. In fact, the paradigm of a programming language is very closely related to its application scenario, whether it is for a single application area or for multiple application areas. 

A typical example is Dart. Its main application scenario is the Web front-end, and it is often used as a support language for the GUI framework Flutter. It is obvious that most of the GUI frameworks we use have a complex inheritance structure. This is because, for GUIs, most of its application scenarios satisfy the Liskov Substitution Principle, i.e., the child type can completely replace the parent type. This is a sufficient condition for using inheritance. Therefore, Dart only provides object-oriented concepts based on inheritance.

The next example is Java, which has weak support for both FP and OOP concepts. In the early years, Java was used for Enterprise development. Later it was used for Web servers, a scenario that required high abstraction of business logic, so Java added the additional concept of FP. However, due to the design of the language itself, the level of support is not high.

Another example is Kotlin, which has better support for both FP and OOP. Its initial application scenario is Android. In order to solve the previous problem that Java was too cumbersome to develop Android applications, Kotlin was designed to add a lot of FP and OOP concepts for the Android application scenario. Not only does it support traditional FP and OOP concepts, but it also makes syntax-level optimizations for these concepts, such as the FP syntactic sugar "trailing lambda" and the OOP delegate syntactic sugar "by". These useful features in turn allow Kotlin to be used in other scenarios, such as server front-ends and back-ends.

## Analysis of type systems

The discussion here is based on L Cardelli's definition of type systems. This definition considers that the fundamental purpose of the type system is to prevent errors that occur during the runtime of a program, and therefore defines the type system by defining concepts related to errors. Good behavior is first defined by defining what is an error. Then it is divided into dynamic checking and static checking based on the timing of the programming language's behavior checking. On the basis of static checking, strong type checking and weak type checking are classified by whether the programming language can check forbidden errors. For the types of variables in programming languages, typed (static) languages and untyped (static) languages are classified according to whether or not there are static types to limit the range of variable types at runtime. Then explicitly typed languages and implicitly typed languages are classified according to whether the programming language explicitly specifies the type of the variable.

A very confusing issue is that the definition of the type system of programming languages varies from context to context. A typical example is the type system of JavaScript. According to P Thiemann's analysis, JavaScript is an untyped programming language. But according to S Li, JavaScript is a dynamically typed language. Another thing worth discussing is Python. Type hints were introduced in Python in version 3.5. But type hints do not actually do error checking for Python. It is simply a type annotation to help provide better support for static analysis syntax parsers. The real time for error checking is still at runtime.

The above table gives the type system of common MPLs according to L Cardelli's type system definition. It is worth noting that most current MPLs have certain commonalities. They are often explicitly typed, strongly typed, statically typed, and well-behaved. This is inseparable from the application areas of these languages. Type signatures contain constraint information by which the behavior of variables or functions can be indirectly determined. It improves maintainability, which is exactly what programming languages for industrial applications need. Static type checking and formal proofs of type systems improve the reliability of programs and help people write less error-prone code. Also, a static type system is more conducive to performance optimization and memory allocation, and object programs can have better performance.

## Analysis of performance

