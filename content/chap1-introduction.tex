\section{Introduction}

In programming language theory(PLT), programming language design has always been an important topic. Because programming language design integrates various branches of PLT, it is the prerequisite for the final realization of programming language. By analyzing the design of modern programming languages(MPL), we can obtain the trend of programming language development, i.e., the programming language design can be fed back from the application point of view.

By and large, the overall amount of literature on the analysis of
programming language design is relatively small.
M Coblenz argues that programming language design should be
considered in terms of several theories related to programming
languages and gives a way of evaluating programming language
design\cite{coblenz2018interdisciplinary}.
A Stefika gives some issues to consider in programming language
design and argues that type systems are crucial for
programming languages\cite{stefik2014programming}.
However, the above results focus on a qualitative analysis of
programming language design and lack some concrete examples.
LA Meyerovich analyzes the usage of popular programming languages
to give best practices in programming language design
through statistics\cite{meyerovich2013empirical}.
This analytical approach is somewhat lacking in theoretical and
systematic aspects.
F Morandat provides a systematic analysis of the R language,
including performance, syntactic design, and application
scenarios\cite{morandat2012evaluating}.
The article adopts a better research approach and can be used to
broaden the analysis perspective based on that article.
Currently, there is a lack of a systematic, theoretical and
practical, wide-ranging, application-oriented analysis of
programming language design.

By analyzing the design of MPL, this paper draws the influence of different programming language factors on the application. e.g., as programming languages evolve, why does the level of paradigm support in MPLs keep changing, what type systems are in MPLs, how MPLs keep programs efficient, and so on.